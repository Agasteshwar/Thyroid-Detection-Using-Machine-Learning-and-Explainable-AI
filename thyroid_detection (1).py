# -*- coding: utf-8 -*-
"""thyroid_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vtD2T7FNWIzFPwZx5d6TxW4ChWeln_w-
"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn. linear_model import LinearRegression
from sklearn.metrics import accuracy_score,roc_curve
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

label_encoder = LabelEncoder()
df1['Class'] = label_encoder.fit_transform(df1['Class'])

df = pd.read_csv('/content/thyroid_sample.csv')
df = pd.read_csv('/content/thyroid_sample.csv')
df1=df.dropna()
df1.describe()
df1.info()

correlation_matrix = df1.corr()

# Create a heatmap of the correlation matrix
plt.figure(figsize=(16, 6))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f")
plt.show()

X = df1.drop('Class', axis=1)
y = df1['Class']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.linear_model import LogisticRegression
lr=LogisticRegression()
lr.fit(X_train,y_train)

lr_prediction=lr.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(lr_prediction,y_test)


target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(accuracy)
print(classification_report(y_test,lr_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, lr_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=target_names)
fig, ax = plt.subplots(figsize=(14,10))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.naive_bayes import GaussianNB
Gnb=GaussianNB()
Gnb.fit(X_train,y_train)

gnb_prediction=Gnb.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(gnb_prediction,y_test)
print(accuracy)

target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(classification_report(y_test,gnb_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, gnb_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=target_names)
fig, ax = plt.subplots(figsize=(15,15))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.tree import DecisionTreeClassifier
dt=DecisionTreeClassifier(criterion='entropy',splitter='best',)
dt.fit(X_train,y_train)

dt_prediction=dt.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(dt_prediction,y_test)
print(accuracy)

target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(classification_report(y_test,dt_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, dt_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=target_names)
fig, ax = plt.subplots(figsize=(15,15))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.ensemble import RandomForestClassifier
rf=RandomForestClassifier(n_estimators=1000,criterion='log_loss',max_features='log2',)
rf.fit(X_train,y_train)

rf_prediction=rf.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(rf_prediction,y_test)
print(accuracy)

target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(classification_report(y_test,rf_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, rf_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=target_names)
fig, ax = plt.subplots(figsize=(14,10))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.svm import SVC
svc=SVC(kernel='sigmoid')
svc.fit(X_train,y_train)
svm_prediction=svc.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(svm_prediction,y_test)
print(accuracy)

target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(classification_report(y_test,svm_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, svm_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=target_names)
fig, ax = plt.subplots(figsize=(15,15))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.neighbors import KNeighborsClassifier
knn=KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train,y_train)
knn_prediction=knn.predict(X_test)
from sklearn.metrics import accuracy_score,classification_report ,confusion_matrix,ConfusionMatrixDisplay
accuracy=accuracy_score(knn_prediction,y_test)
print(accuracy)

target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid']
print(classification_report(y_test,knn_prediction.reshape(-1,1),target_names=target_names))

cm = confusion_matrix(y_test, knn_prediction.reshape(-1,1), normalize='true')
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=target_names)
fig, ax = plt.subplots(figsize=(15,15))
disp.plot(ax=ax,cmap='Blues')
plt.show()

from sklearn.metrics import classification_report

# Replace the roc_curve lines with the following:

# Get the classification report
report = classification_report(y_test, svm_prediction, target_names=['compensated hypothyroid','hyperthyroid','negative','primary hypothyroid','secondary hypothyroid'])

# Print the classification report
print(report)

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt
from sklearn.preprocessing import label_binarize

# Binarize the output
y_test_bin = label_binarize(y_test, classes=np.unique(y_test)) # Binarize y_test
lr_prediction_bin = label_binarize(lr_prediction, classes=np.unique(y_test)) # Binarize lr_prediction
n_classes = y_test_bin.shape[1]

# Compute ROC curve and ROC area for each class
â€¦    plt.plot(fpr[i], tpr[i], marker='.', label='Class %d (auc = %0.3f)' % (i, roc_auc[i]))

plt.xlabel('False Positive Rate -->')
plt.ylabel('True Positive Rate -->')
plt.legend()
plt.show()

!pip install shap

!pip install shap
import shap
import matplotlib.pyplot as plt

# load JS visualization code to notebook
shap.initjs()

# Create the explainer`
explainer = shap.TreeExplainer(rf)

shap_values = explainer.shap_values(X_test)